<!DOCTYPE html>
<html>
<head>
  <title>ArcGIS JS API - Карта с векторными тайлами</title>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no">
  <link rel="stylesheet" href="https://js.arcgis.com/4.23/esri/themes/light/main.css"/>
  <link  href="https://cdn.socket.io/4.6.0/socet.io.min.js"/>
  <link rel="stylesheet" href="style.css">
<script src="https://js.arcgis.com/4.23/"></script>
  <style>
    /* Reset and base styles  */
    * {
      padding: 0px;
      margin: 0px;
      border: none;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    /* Links */

    a, a:link, a:visited  {
        text-decoration: none;
    }

    a:hover  {
        text-decoration: none;
    }

    /* Common */

    aside, nav, footer, header, section, main {
      display: block;
    }

    h1, h2, h3, h4, h5, h6, p {
        font-size: inherit;
      font-weight: inherit;
    }

    ul, ul li {
      list-style: none;
    }

    img {
      vertical-align: top;
    }

    img, svg {
      max-width: 100%;
      height: auto;
    }

    address {
      font-style: normal;
    }

    /* Form */

    input, textarea, button, select {
      font-family: inherit;
        font-size: inherit;
        color: inherit;
        background-color: transparent;
    }

    input::-ms-clear {
      display: none;
    }

    button, input[type="submit"] {
        display: inline-block;
        box-shadow: none;
        background-color: transparent;
        background: none;
        cursor: pointer;
    }

    input:focus, input:active,
    button:focus, button:active {
        outline: none;
    }

    button::-moz-focus-inner {
      padding: 0;
      border: 0;
    }

    label {
      cursor: pointer;
    }

    legend {
      display: block;
    }

    html,
    body,
    #viewDiv {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    .track_offset{
      display:flex;
      justify-content: space-between;

    }
    .track_offset div{
      display:flex;
      align-items: center;
    }
    input{
      border: 1px solid black;
      width:50px;
      height: 20px;
      font-size: 12px;
    }
    body{
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    .btn {
      display: inline-block;	
      box-sizing: border-box;
      padding: 0 15px;
      outline: none;
      border: none;  
      border-radius: 4px;
      height: 36px;
      line-height: 36px;
      font-size: 14px;
      font-weight: 500;
      text-decoration: none;
      color: #fff;
      background-color: #1a73e8;
      position: relative;
      overflow:hidden;
      vertical-align: top;
      cursor: pointer;
      user-select: none;
      appearance: none;
      touch-action: manipulation; 
      z-index: 1;
    }
    .btn span{
      position: absolute;
      background: #fff;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      pointer-events: none;
      animation: btn_ripples 0.6s linear infinite;
    }
    @keyframes btn_ripples {
      0% {
        width: 0px;
        height: 0px;
        opacity: 0.5;
      }
      100% {
        width: 1000px;
        height: 1000px;
        opacity: 0;
      }
    }
    .btn:hover {
      box-shadow: 0 1px 2px 0 rgb(26 115 232 / 45%), 0 1px 3px 1px rgb(26 115 232 / 30%);
      background-color: #297be6;
    }
    .btn:active {
      box-shadow: 0 1px 2px 0 rgb(26 115 232 / 45%), 0 2px 6px 2px rgb(26 115 232 / 30%);
      background-color: #1a73e8 !important;
    }
    .btn:focus-visible {
      box-shadow: 0 0 0 3px lightskyblue;
    }
    .btn:disabled {
      pointer-events: none;
      opacity: 0.65;
    }
  </style>
</head>
<body>
  <div class="track_offset">
    <div>
      <p>Смещение трека: </p>
      <input value="0" id= "offset"type="text">
    </div>
    <button type="button" disabled class="save_track btn">Зафиксировать трек</button>
  </div>
  <div id="viewDiv"></div>
  <div class="footer"> <button type="button" disabled class="save_sign btn">Сохранить знаки</button></div>
  <script type="module">
    document.getElementById('offset').addEventListener("input",()=>{
      let numberOffset =parseInt( document.getElementById('offset').value);
      let is_active = (!Number.isInteger(numberOffset)) && numberOffset ==0
      document.querySelector(".save_track").disabled = !Number.isInteger(numberOffset) ;
      if (Number.isInteger(numberOffset)){
        document.querySelector(".save_track").disabled = numberOffset == 0
      }
    })

    document.querySelector(".save_track").addEventListener("click",()=>{
      let numberOffset =parseInt( document.getElementById('offset').value);
      if (!Number.isInteger(numberOffset)){
        numberOffset = 0
      }
      if (numberOffset != 0){
        fetch(`http://127.0.0.1:3000/save_track?index_offset_track=${numberOffset}`)
        .then((response) => {
          if (response.status == 200) {
            location.reload();
          }
        })
        .catch((error) =>
          console.error("Ошибка при получении новой линии:", error)
        );
      }

    })
    const requestURL = 'http://127.0.0.1:3000/track'
    import { io } from "https://cdn.socket.io/4.7.5/socket.io.esm.min.js";


   const socket = io({autoConnect: false})

   socket.connect()

    const fetchGPX = async (url) => {
      return  fetch(url).then(response => response.json());
    }
    
    fetchGPX(requestURL).then(coordinates => {
      require([
      "esri/Map",
      "esri/views/MapView",
      "esri/layers/VectorTileLayer",
      "esri/layers/GraphicsLayer",
      "esri/Graphic",
      "esri/geometry/Polyline",
      "esri/geometry/Point",
      "esri/layers/FeatureLayer", // Import FeatureLayer
      "esri/symbols/SimpleMarkerSymbol", // Import SimpleMarkerSymbol
      "esri/symbols/PictureMarkerSymbol",
      "esri/renderers/SimpleRenderer", // Import SimpleRenderer

    ], function (
      Map,
      MapView,
      VectorTileLayer,
      GraphicsLayer,
      Graphic,
      Polyline,
      Point,
      FeatureLayer,
      SimpleMarkerSymbol,
      PictureMarkerSymbol,
      SimpleRenderer,
    ) {

      const vectorTileLayer = new VectorTileLayer({
        url: "https://gis.maps.by/arcgis/rest/services/Hosted/VectorTile_240522/VectorTileServer",
      });

      const map = new Map({
        layers: [vectorTileLayer],
      });
        
      var graphicsLayer = new GraphicsLayer();
      map.add(graphicsLayer);
      const view = new MapView({
        center: [27.5, 53.9],
        container: "viewDiv",
        map: map,
        zoom: 10,
      });
      let number_rount = 7
      let isMoveSign = false
      let type_for_moving = null
      let azimuth_for_moving = null
      let coordinates_for_moving
      let geojson_id 
      view.on("click", async (event) => {
        view.hitTest(event).then((response) =>{
          if (response.results.length == 2 && !isMoveSign) {
            if (response.results[0].graphic._imageUrl === undefined){
              var points = response.results[0].graphic.geometry.paths[0]
              geojson_id = response.results[0].geojson_id
              const x_line =( (points[0][0] + points[1][0]) / 2).toFixed(number_rount)
              const y_line =( (points[0][1] + points[1][1]) / 2).toFixed(number_rount)
              graphicsLayer.graphics.forEach((item) =>{
                if (item._imageUrl !== undefined){
                  let x_img = item.geometry.x.toFixed(number_rount)
                  let y_img = item.geometry.y.toFixed(number_rount)
                  if (x_line == x_img && y_line == y_img){
                    let type = item._imageUrl.split('/')
                    type = type[type.length-1]
                    type_for_moving = type
                    azimuth_for_moving = item.azimuth
                    coordinates_for_moving = points

                    graphicsLayer.remove(item)
                    graphicsLayer.remove(response.results[0].graphic)
                    isMoveSign = true
                  }
                }
              })

            }else if (!isMoveSign){
              let type = response.results[0].graphic._imageUrl.split('/')
              type = type[type.length-1]
              type_for_moving = type
              azimuth_for_moving = response.results[0].graphic.azimuth
              let x_img = response.results[0].graphic.geometry.x.toFixed(number_rount)
              let y_img = response.results[0].graphic.geometry.y.toFixed(number_rount)
              graphicsLayer.graphics.forEach((item) =>{
                if (item._imageUrl === undefined){
                  var points = item.geometry.paths[0]
                  const x_line =( (points[0][0] + points[1][0]) / 2).toFixed(number_rount)
                  const y_line =( (points[0][1] + points[1][1]) / 2).toFixed(number_rount)
                  if (x_line == x_img && y_line == y_img){
                    coordinates_for_moving = points 
                    geojson_id = item.geojson_id
                    graphicsLayer.remove(item)
                    graphicsLayer.remove(response.results[0].graphic)
                    isMoveSign = true
                  }
                }
              })
            }
            } else if (response.results.length == 1){
              if (isMoveSign){
                let new_x = parseFloat(event.mapPoint.longitude.toFixed(number_rount))
                let new_y = parseFloat(event.mapPoint.latitude.toFixed(number_rount))                
                const url = `http://127.0.0.1:3000/create_new_line?old_line=${coordinates_for_moving.toString()}&new_point=${new_x},${new_y}`;
                fetch(url)
                .then((response) => response.text())
                .then((data) => {
                  let new_point = data.split(',').map(item=>{return parseFloat(item)})
                  let new_line = [[new_x, new_y], new_point ]
                  createLine(new_line, geojson_id)
                  createImage(type_for_moving, new_line, azimuth_for_moving)
                  document.querySelector(".save_sign").disabled = false
                  isMoveSign = false
                })
                .catch((error) =>
                  console.error("Ошибка при получении новой линии:", error)
                );
              }
              
            }


        })});
      
      const markerSymbol = {
        type: "simple-marker",
        color: [226, 119, 40],
        outline: {
          color: [255, 255, 255],
          width: 2,
        },
      };
     const points = coordinates.map(item => {
      const point =  new Point({longitude: item[1],latitude: item[0] });
      return new Graphic({geometry: point, symbol: markerSymbol})})
      let pointLayer = new FeatureLayer({
        source: points,
        renderer: new SimpleRenderer({
          symbol: new SimpleMarkerSymbol({
            color: [226, 119, 40],
            outline: {
              color: [255, 255, 255],
              width: 1,
            },
          }),
        }),
        objectIdField: "ObjectID",
      });

      map.add(pointLayer)
      let points2 = points.slice(0,10)//[new Graphic({geometry:  new Point({longitude: points[data]["geometry"]["latitude"],latitude: points[data]["geometry"]["longitude"], }), symbol: markerSymbol})]
      
      var currentPointLayer = new FeatureLayer({
        source: [points[Math.floor(Math.random()*points.length)]],
        renderer: new SimpleRenderer({
          symbol: new SimpleMarkerSymbol({
            color: [0, 0, 0],
            outline: {
              color: [255, 255, 255],
              width: 1,
            },
          }),
        }),
        objectIdField: "ObjectID",
      });
      let prewPoint = 0
      let standart_color_point = {r:226, g:119, b:40, a:1}
      let active_color_point = {r:10, g:10, b:10, a:1}

      let xcoord = coordinates[0][1]
      let ycoord = coordinates[0][0]
      view.goTo({
        center: [xcoord, ycoord],
        zoom: 17,
        duration: 1000,
        easing: "ease-out",
      });

      socket.on("change_dot", function(data){
        let numberOffset =parseInt( document.getElementById('offset').value);
        if (!Number.isInteger(numberOffset)){
          numberOffset = 0
        }

        let resultIndex = data + numberOffset
        resultIndex = resultIndex < 0 ? 0: resultIndex
        resultIndex = resultIndex > points.length ? points.length-1: resultIndex

        map.remove(currentPointLayer);
        currentPointLayer = new FeatureLayer({
          source: [points[resultIndex]],
          renderer: new SimpleRenderer({
            symbol: new SimpleMarkerSymbol({
              color: [0, 0, 0],
              outline: {
                color: [255, 255, 255],
                width: 1,
              },
            }),
          }),
          objectIdField: "ObjectID",
        });

        map.add(currentPointLayer)
      })

      const displayZoomLevel = 15; 
      function loadGeoJSON() {
        fetch("http://127.0.0.1:3000/geojson")
          .then((response) => response.json())
          .then((data) => {
            processGeoJSON(data);
          })
          .catch((error) =>
            console.error("Ошибка при загрузке GeoJSON:", error)
          );
      }
      function getImageUrl(type) {
        const match = type.match(/[0-9.]+/);
        const fileName = match ? match[0] : "";
        return `http://127.0.0.1:3000/img_type/${fileName}`;
      }
      
      function createLine(coordinates, geojson_id){
        const pointStart = {
          x: coordinates[0][0],
          y: coordinates[0][1],
        };
        const pointEnd = {
          x: coordinates[1][0],
          y: coordinates[1][1],
        };
        const polyline = new Polyline({
          type: "polyline",
          paths: [
            [
              [pointStart.x, pointStart.y],
              [pointEnd.x, pointEnd.y],
            ],
          ],
        });

        let lineGraphic = new Graphic({
          geometry:  polyline,
          symbol: {
            type: "simple-line",
            color: [4, 90, 141],
            width: 2,
          },
          geojson_id: geojson_id
        });
        graphicsLayer.add(lineGraphic);
      }

      function createImage(imageType, coordinates, azimuth){
        const imageUrl = getImageUrl(imageType);
        const image = new Image();
        image.src = imageUrl;
        image.onload = function () {
          const scaleFactor = 0.50;
          const pictureMarkerSymbol = new PictureMarkerSymbol({
            url: imageUrl,
            width: image.width * scaleFactor,
            height: image.height * scaleFactor,
            angle: azimuth,
          });

          const imageCenterPoint = new Point({
            x: (coordinates[0][0] + coordinates[1][0]) / 2,
            y: (coordinates[0][1] + coordinates[1][1]) / 2,
          });

          const imageGraphic = new Graphic({
            geometry: imageCenterPoint,
            symbol: pictureMarkerSymbol,
            azimuth:azimuth
          });
          imageGraphic._imageUrl = imageUrl;
        
          graphicsLayer.add(imageGraphic);
        };
      }

      function processGeoJSON(geojson) {
        geojson.forEach((feature) => {
          const coordinates = feature.coordinates;
          const azimuth = feature.azimuth;
          const imageType = feature.type;
          const geojson_id = feature.id
          createLine(coordinates, geojson_id)

          createImage(imageType, coordinates, azimuth)

        });
      }

      
      function updateVisibleGraphics() {
        const currentZoom = view.zoom; 
        const visibleExtent = view.extent;


        graphicsLayer.graphics.forEach((graphic) => {
          const point = graphic.geometry;
            if (currentZoom >= displayZoomLevel) {
              graphic.visible = true;
            } else {
              graphic.visible = false;
            }
        });
      }

      view.watch("stationary", function () {
        updateVisibleGraphics();
      });

      view.watch("zoom", function () {
        updateVisibleGraphics();
      });

      loadGeoJSON()
      document.querySelector(".save_sign").addEventListener("click",()=>{
        var new_points = []
        graphicsLayer.graphics.forEach(item =>{
          if(item.geojson_id !== undefined){
            let id = item.geojson_id
            let line = item.geometry.paths[0]
            new_points.push({id:id, line: line})
          }
        })
        fetch('http://127.0.0.1:3000/save_geojson', {
          method: 'POST', // or 'PUT'
          headers: {
           'Content-Type': 'application/json'
          },
          body: JSON.stringify(new_points)
         })
         .then(response => response.json())
         .then(data => {
          console.log('Success:', data);
         })
         .catch(error => {
          console.error('Error:', error);
         });
      })
    });
    })
    
    
  </script>


</body>
</html>